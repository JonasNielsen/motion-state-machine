{"name":"motion-state-machine","body":"# motion-state-machine\r\n\r\nHey, this is `motion-state-machine` — a state machine gem designed for\r\n[RubyMotion](http://rubymotion.com) for iOS.\r\n\r\n## Motivation\r\n\r\nUndefined states and visual glitches in applications with complex UIs can\r\nbe a hassle, especially when the UI is animated and the app has to handle\r\nasynchronous data retrieved in the background.\r\n\r\nWell-defined UI state machines avoid these problems while ensuring that\r\nasynchronous event handling does not lead to undefined results (a.k.a. bugs).\r\n\r\nMacRuby and Cocoa don't provide a simple library to address this —\r\nmotion-state-machine should fill the gap for RubyMotion developers.\r\n\r\nmotion-state-machine comes with a simple and nice-looking syntax to define\r\nstates and transitions:\r\n\r\n    fsm = StateMachine::Base.new start_state: :awake\r\n\r\n\tfsm.when :awake do |state|\r\n\t   state.on_entry { puts \"I'm awake, started and alive!\" }\r\n\t   state.transition_to :sleeping, on:  :finished_hard_work,\r\n\t   state.die on: :too_hard_work\r\n\tend\r\n\r\nIt is [Grand Central Dispatch](https://developer.apple.com/library/mac/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html)-aware\r\nand uses GCD queues for synchronization.\r\n\r\n## Installation\r\n\r\n1. If not done yet, add `bundler` gem management to your RubyMotion app.\r\n   See <http://thunderboltlabs.com/posts/using-bundler-with-rubymotion> for\r\n   an explanation how.\r\n\r\n2. Add this line to your application's Gemfile:\r\n\r\n\t\tgem 'motion-state-machine',\r\n\t\t  git: \"git://github.com/opyh/motion-state-machine.git\"\r\n\r\n3. Execute:\r\n\r\n\t\t$ bundle\r\n\r\n## Usage\r\n\r\nThe following example shows how to initialize and define a state machine:\r\n\r\n\tfsm = StateMachine::Base.new start_state: :working, verbose: true\r\n\r\nThis initializes a state machine. Calling `fsm.start!` would start the\r\nmachine in the defined start state `:working`. Using `:verbose` activates\r\ndebug output on the console.\r\n\r\n### Defining states and transitions\r\n\r\nAfter initialization, you can define states and transitions:\r\n\r\n\tfsm.when :working do |state|\r\n\r\n\t   state.on_entry { puts \"I'm awake, started and alive!\" }\r\n\t   state.on_exit { puts \"Phew. That was enough work.\" }\r\n\r\n\t   state.transition_to :sleeping,\r\n\t     on:      :finished_hard_work,\r\n\t     if:      proc { really_worked_enough_for_now? },\r\n\t     action:  proc { puts \"Will go to sleep now.\" }\r\n\r\n\t   state.die on: :too_hard_work\r\n\r\n\tend\r\n\r\nThis defines…\r\n\r\n1. An entry and an exit action block, called when entering/exiting the state\r\n   :working.\r\n\r\n2. a transition from state `:working` to `:sleeping`, happening when calling\r\n   `fsm.event(:finished_hard_work)`.\r\n\r\n   Before the transition is executed, the state machine asks the `:if` guard\r\n   block if the transition is allowed. Returning `false` in this block would\r\n   prevent the transition from happening.\r\n\r\n   If the transition is executed, the machine calls the given `:action` block.\r\n\r\n3. another transition that terminates the state machine when calling\r\n   `fsm.event(:too_hard_work)`. When terminated, the state machine stops\r\n   responding to events.\r\n\r\nNote that a transition from a state to itself can be _internal_: Entry/exit\r\nactions are not called on execution in this case.\r\n\r\n### Handling events, timeouts and NSNotifications\r\n\r\nTransitions can be triggered…\r\n\r\n- by calling the state machine's `#event` method (see above).\r\n\r\n- automatically after a given timeout:\r\n\r\n\t\tfsm.when :sleeping do |state|\r\n\t\t  state.transition_to :working, after: 20\r\n\t\tend\r\n\r\n  (goes back to `:working` after 20 seconds in state `:sleeping`)\r\n\r\n- when a `NSNotification` is posted:\r\n\r\n\t\tfsm.when :awake do |state|\r\n\t\t  state.transition_to :in_background,\r\n\t\t    on_notification: UIApplicationDidEnterBackgroundNotification\r\n\t\tend\r\n\r\n### How fast is it?\r\n\r\nThe implementation is designed for general non-performance-intensive purposes\r\nlike managing UI state behavior. It may be too slow for parsing XML, realtime\r\nsignal processing with high sample rates and similar tasks.\r\n\r\nAnyways, it should be able to handle several thousand events per second on\r\nan iOS device.\r\n\r\n## Contributing\r\n\r\nFeel free to fork the project and send me a pull request if you would\r\nlike me to integrate your bugfix, enhancement, or feature.\r\n\r\nYou can easily add new triggering mechanisms — they can be\r\nimplemented in few lines by subclassing the `Transition` class (see\r\nthe implementation of `NotificationTransition` for an example).\r\n\r\nI'm also open for suggestions regarding the interface design.\r\n\r\nTo contribute,\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Added some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n\r\nIf the feature has specs, I will probably merge it :)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"A state machine gem designed for RubyMotion."}